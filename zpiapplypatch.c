#include <stdio.h>
#include <sys/types.h> 
#include <sys/wait.h>
#include <sys/types.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <zlib.h>



#define APP_NAME  "zpiapplypatch"
#define ERR_NAME "errapplypatch"

#include <android/log.h>
#define LOGV(...) { __android_log_print(ANDROID_LOG_INFO,  APP_NAME, __VA_ARGS__); }
#define LOGERR(...) { __android_log_print(ANDROID_LOG_INFO,  ERR_NAME, __VA_ARGS__); }

//#define DEV_BLOCK_ID "/dev/block/mmcblk0p"
//#define LSLR_DEV_BLOCK "/system/bin/ls -lR /dev/block/platform/msm_sdcc.1/by-name/frp 2>&1"
//#define LSLR_DEV_BLOCK "/system/bin/ls -lR " DEV_BLOCK_ID " 2>&1"

#define DEV_BLOCK_PLATFORM_NAME "/dev/block/platform/msm_sdcc.1/by-name/"
//#define LSLR_DEV_BLOCK "/system/bin/ls -lR %s 2>&1"
#define LSLR_DEV_BLOCK "/system/bin/md5 %s 2>&1"

const char *names[] = {
    "abootBackup",		// /dev/block/mmcblk0p11	512
    "aboot",		    // /dev/block/mmcblk0p4	    512
    "boot",		        // /dev/block/mmcblk0p31	10240
    "cache",		    // /dev/block/mmcblk0p33	678016
    "cid",		        // /dev/block/mmcblk0p25	128
    "clogo",		    // /dev/block/mmcblk0p28	4096
    "DDR",		        // /dev/block/mmcblk0p3	    32
    "dhob",		        // /dev/block/mmcblk0p20	8
    "fsc",		        // /dev/block/mmcblk0p22	1
    "fsg",		        // /dev/block/mmcblk0p21	1536
    "hob",		        // /dev/block/mmcblk0p19	512
    "kpan",		        // /dev/block/mmcblk0p35	8192
    "logo",		        // /dev/block/mmcblk0p27	4096
    "logs",		        // /dev/block/mmcblk0p9	    2048
    "misc",		        // /dev/block/mmcblk0p30	512
    "modem",		    // /dev/block/mmcblk0p1	    65536
    "modemst1",		    // /dev/block/mmcblk0p17	1536
    "modemst2",		    // /dev/block/mmcblk0p18	1536
    "padA",		        // /dev/block/mmcblk0p10	2332
    "padB",		        // /dev/block/mmcblk0p16	1052
    "pds",		        // /dev/block/mmcblk0p26	3072
    "persist",		    // /dev/block/mmcblk0p29	8192
    "recovery",		    // /dev/block/mmcblk0p32	10240
    "rpmBackup",		// /dev/block/mmcblk0p12	200
    "rpm",		        // /dev/block/mmcblk0p5 	200
    "sbl1",		        // /dev/block/mmcblk0p2	    512
    "sdiBackup",		// /dev/block/mmcblk0p14	32
    "sdi",		        // /dev/block/mmcblk0p7	    32
    "sp",		        // /dev/block/mmcblk0p24	1024
    "ssd",		        // /dev/block/mmcblk0p23	8
    "system",		    // /dev/block/mmcblk0p34	999424
    "tzBackup",		    // /dev/block/mmcblk0p13	400
    "tz",		        // /dev/block/mmcblk0p6	    400
    "userdata",		    // /dev/block/mmcblk0p36	13545344
    "utagsBackup",		// /dev/block/mmcblk0p15	512
    "utags",		    // /dev/block/mmcblk0p8	    512
    NULL
};

const char *block_ids[] = {
    "/dev/block/zram0",		    //              262144
    "/dev/block/mmcblk0",		//              15388672
    "/dev/block/mmcblk0p1",		// modem    	65536
    "/dev/block/mmcblk0p2",		// sbl1 	    512
    "/dev/block/mmcblk0p3",		// DDR  	    32
    "/dev/block/mmcblk0p4",		// aboot	    512
    "/dev/block/mmcblk0p5",		// rpm  	    200
    "/dev/block/mmcblk0p6",		// tz       	400
    "/dev/block/mmcblk0p7",		// sdi      	32
    "/dev/block/mmcblk0p8",		// utags    	512
    "/dev/block/mmcblk0p9",		// logs     	2048
    "/dev/block/mmcblk0p10",	// padA     	2332
    "/dev/block/mmcblk0p11",	// abootBackup	512
    "/dev/block/mmcblk0p12",	// rpmBackup	200
    "/dev/block/mmcblk0p13",	// tzBackup 	400
    "/dev/block/mmcblk0p14",	// sdiBackup	32
    "/dev/block/mmcblk0p15",	// utagsBackup	512
    "/dev/block/mmcblk0p16",	// padB     	1052
    "/dev/block/mmcblk0p17",	// modemst1 	1536
    "/dev/block/mmcblk0p18",	// modemst2 	1536
    "/dev/block/mmcblk0p19",	// hob      	512
    "/dev/block/mmcblk0p20",	// dhob     	8
    "/dev/block/mmcblk0p21",	// fsg      	1536
    "/dev/block/mmcblk0p22",	// fsc      	1
    "/dev/block/mmcblk0p23",	// ssd      	8
    "/dev/block/mmcblk0p24",	// sp       	1024
    "/dev/block/mmcblk0p25",	// cid      	128
    "/dev/block/mmcblk0p26",	// pds      	3072
    "/dev/block/mmcblk0p27",	// logo     	4096
    "/dev/block/mmcblk0p28",	// clogo    	4096
    "/dev/block/mmcblk0p29",	// persist  	8192
    "/dev/block/mmcblk0p30",	// misc     	512
    "/dev/block/mmcblk0p31",	// boot     	10240
    "/dev/block/mmcblk0p32",	// recovery 	10240
    "/dev/block/mmcblk0p33",	// cache    	678016
    "/dev/block/mmcblk0p34",	// system   	999424
    "/dev/block/mmcblk0p35",	// kpan     	8192
    "/dev/block/mmcblk0p36",	// userdata 	13545344
    "/dev/block/mmcblk0rpmb",	//          	4096
    NULL
};

static int mypclose(FILE *in)
{
    int ret = pclose(in); // wait for process to finish.
    if (ret == -1)
    {
        LOGERR("pclose failed: %m");
        goto err;
    }
    else if (ret != 0)
    {
        // See the fork() examples where we also call wait(). pclose()
        // works similar to wait().
        if (WIFEXITED(ret)) {
            //LOGERR("The process exited NORMALLY with return value %u", WEXITSTATUS(ret));
            goto err;
        }
        else if (WIFSIGNALED(ret)) {
            //LOGERR("The process was terminated due to an UNHANDLED SIGNAL %u", WTERMSIG(ret));
            goto err;
        }
    }

    return 0;

err:
    return -1;
}

int run_command(char *cmd)
{
    char tmp[1000];
    /* Get the tree command output */
    FILE *pp = popen(cmd, "r");
    if (pp != NULL) {
        while (1) {
            char *line = fgets(tmp, sizeof tmp, pp);
            if (line == NULL)
                break;
            else {
                int len = strlen(line);
                /* replace newline at the end of line with null character */
                line[len-1] = '\0';
                LOGERR("%s", line);
            }
        }
        if (mypclose(pp) == -1)
            return -1;
    } else {
        LOGERR("cannot run %s", cmd);
        return -1;
    }
    return 0;
}

void do_copy(const char *name)
{
    char cmd1[200];
    sprintf(cmd1, "cat /dev/block/platform/msm_sdcc.1/by-name/%s > /cache/zpibackup_%s", name, name);
    char cmd2[200];
    sprintf(cmd2, "/system/bin/md5 /dev/block/platform/msm_sdcc.1/by-name/%s /cache/zpibackup_%s 2>&1", name, name);
    run_command(cmd1);
    run_command(cmd2);
}

static char encode6Bit(unsigned x) {
    if (x <= 25) {
        return 'A' + x;
    } else if (x <= 51) {
        return 'a' + x - 26;
    } else if (x <= 61) {
        return '0' + x - 52;
    } else if (x == 62) {
        return '+';
    } else {
        return '/';
    }
}

// adb truncates to 1024

//#define CHUNK_IN 16384
#define CHUNK_IN 256000
#define CHUNK_OUT 750
#define MAXOUT 1000 // logcat max out

void encodeBase64(
        const void *_data, size_t size, int delay) {
    const uint8_t *data = (const uint8_t *)_data;
    size_t i;
    size_t j = 0;
    char out[MAXOUT + 1];
    out[0] = '\0';
    for (i = 0; i < (size / 3) * 3; i += 3) {
        uint8_t x1 = data[i];
        uint8_t x2 = data[i + 1];
        uint8_t x3 = data[i + 2];
        out[j++] = (encode6Bit(x1 >> 2));
        out[j++] = (encode6Bit((x1 << 4 | x2 >> 4) & 0x3f));
        out[j++] = (encode6Bit((x2 << 2 | x3 >> 6) & 0x3f));
        out[j++] = (encode6Bit(x3 & 0x3f));
#if 0
        if (j == MAXOUT) {
            out[j] = '\0';
            LOGV("%s", out);
            usleep(100);
            out[0] = '\0';
            j = 0;
        }
#endif
    }
    switch (size % 3) {
        case 0:
            break;
        case 2:
        {
            uint8_t x1 = data[i];
            uint8_t x2 = data[i + 1];
            out[j++] = (encode6Bit(x1 >> 2));
            out[j++] = (encode6Bit((x1 << 4 | x2 >> 4) & 0x3f));
            out[j++] = (encode6Bit((x2 << 2) & 0x3f));
            out[j++] = '=';
            break;
        }
        default:
        {
            uint8_t x1 = data[i];
            out[j++] = (encode6Bit(x1 >> 2));
            out[j++] = (encode6Bit((x1 << 4) & 0x3f));
            out[j++] = '=';
            out[j++] = '=';
            break;
        }
    }
    out[j] = '\0';
    LOGV("%s", out);
    usleep(delay);
}

#define USLEEP_DELAY 1000

/* Compress from file source to file dest until EOF on source.
   def() returns Z_OK on success, Z_MEM_ERROR if memory could not be
   allocated for processing, Z_STREAM_ERROR if an invalid compression
   level is supplied, Z_VERSION_ERROR if the version of zlib.h and the
   version of the library linked do not match, or Z_ERRNO if there is
   an error reading or writing the files. */
int fill_logcat_compressed(int input_fd, int level)
{
    int flush = Z_NO_FLUSH;
    int ret;
    unsigned have;
    z_stream strm;
    unsigned char in[CHUNK_IN];
    unsigned char out[CHUNK_OUT];

    /* allocate deflate state */
    strm.zalloc = Z_NULL;
    strm.zfree = Z_NULL;
    strm.opaque = Z_NULL;
    ret = deflateInit(&strm, level);
    if (ret != Z_OK)
        return ret;

    /* compress until end of file */
    do {
        ssize_t avail_in = read(input_fd, in, CHUNK_IN);
        if (avail_in == -1) {
            (void)deflateEnd(&strm);
            LOGERR("ZPIERROR READ");
            return -1;
        } else if (avail_in == 0) {
            LOGERR("ZPIWEGOTENDOFINPUT");
            flush = Z_FINISH;
        }
        strm.avail_in = avail_in;
        strm.next_in = in;

        /* run deflate() on input until output buffer not full, finish
           compression if all of source has been read in */
        do {
            strm.avail_out = CHUNK_OUT;
            strm.next_out = out;
            ret = deflate(&strm, flush);    /* no bad return value */
            have = CHUNK_OUT - strm.avail_out;
            encodeBase64(out, have, USLEEP_DELAY);
        } while (strm.avail_out == 0);

        /* done when last data in file processed */
    } while (flush != Z_FINISH);

    /* clean up and return */
    (void)deflateEnd(&strm);
    return Z_OK;
}

void do_md5(const char *name)
{
    char cmd2[200];
    sprintf(cmd2, "/system/bin/md5 /dev/block/platform/msm_sdcc.1/by-name/%s 2>&1", name);
    run_command(cmd2);
}

int fill_logcat_uncompressed(int input_fd)
{
    unsigned char in[CHUNK_IN];
    int flush = Z_NO_FLUSH;
    do {
        ssize_t avail_in = read(input_fd, in, CHUNK_IN);
        if (avail_in == -1) {
            LOGERR("ZPIERROR READ");
            return -1;
        } else if (avail_in == 0) {
            LOGERR("ZPIWEGOTENDOFINPUT");
            flush = Z_FINISH;
        }

        ssize_t idx = 0;
        while (idx < avail_in) {
            if (avail_in >= idx + CHUNK_OUT) {
                encodeBase64(&in[idx], CHUNK_OUT, USLEEP_DELAY);
                idx += CHUNK_OUT;
            } else {
                encodeBase64(&in[idx], avail_in - idx, USLEEP_DELAY);
                idx = avail_in;
            }
        }

        /* done when last data in file processed */
    } while (flush != Z_FINISH);
    return 0;
}

int do_read(const char *name, long offset)
{
    int input_fd;

#if 0
I/zpiapplypatch( 6260): 9098223b85778b581183c636df883a76  /dev/block/platform/msm_sdcc.1/by-name/system
I/zpiapplypatch( 6260): filelen = 1023410176
#endif

    char input[200];
    sprintf(input, "/dev/block/platform/msm_sdcc.1/by-name/%s", name);

    /* Create input file descriptor */
    input_fd = open (input, O_RDONLY);
    if (input_fd == -1) {
            LOGERR("input open error");
            return 2;
    }

    int filelen = lseek(input_fd, 0, SEEK_END);
    LOGERR("filelen = %d", filelen);
    int current_offset = lseek(input_fd, offset, SEEK_SET);
    if (current_offset == -1) {
        LOGERR("ZPIERROR FSEEK -1 %s", strerror(errno));
        return -1;
    } else if (current_offset != offset) {
        LOGERR("ZPIERROR FSEEK %d", current_offset);
        return -1;
    }

    //fill_logcat_uncompressed(input_fd);
    //fill_logcat_compressed(input_fd, Z_DEFAULT_COMPRESSION);
    fill_logcat_compressed(input_fd, Z_BEST_COMPRESSION);

    /* Close file descriptors */
    close (input_fd);

    return 0;
}


int main(int argc, char **argv)
{
    int ret = 0;

    int i;
    for (i=0; i<argc; i++)
    {
        LOGERR("argv[%d] = %s", i, argv[i]);
    }

#if 0
    const char *cmd;
    if (strstr(argv[0], "zpitestls") != NULL) {
        cmd = argv[1];
    } else {
        cmd = LSLR_DEV_BLOCK;
    }

    char cmd[1000];
    i = 0;
    const char *blk = block_ids[i];
    while (blk != NULL)
    {
        sprintf(cmd, LSLR_DEV_BLOCK, blk);
        run_command(cmd);
        i ++;
        blk = block_ids[i];
    }

    i = 0;
    const char *name = names[i];
    while (name != NULL)
    {
        char tmp[100];
        sprintf(tmp, "%s%s", DEV_BLOCK_PLATFORM_NAME, name);
        sprintf(cmd, LSLR_DEV_BLOCK, tmp);
        run_command(cmd);
        i ++;
        name = names[i];
    }

    //run_command("mkdir -p /cache/zpibackup 2>&1");
    do_copy("boot");
    do_copy("aboot");
    do_copy("recovery");
#endif
    //do_read("boot");
    //do_read("aboot");
    //do_read("recovery");
    //do_read("abootBackup");
    //do_read("cid");
    //do_read("clogo");
    //do_read("DDR");
    //do_read("dhob");
    //do_read("fsc");
    //do_read("fsg");
    //do_read("hob");
    //do_read("kpan");
    //do_read("logo");
    //do_read("logs");
    //do_read("misc");
    //do_read("modemst1");
    //do_read("modemst2");
    //do_read("padA");
    //do_read("padB");
    //do_read("pds");
    //do_read("persist");
    //do_read("rpmBackup");
    //do_read("rpm");
    //do_read("sbl1");
    //do_read("sdiBackup");
    //do_read("sdi");
    //do_read("sp");
    //do_read("ssd");
    //do_read("tzBackup");
    //do_read("tz");
    //do_read("utagsBackup");
    //do_read("utags");
    //do_md5("system");
    //do_read("system", 755712000);
    //do_read("system", 0);
    do_md5("userdata");
    do_read("userdata", 0);

    return ret;
}
